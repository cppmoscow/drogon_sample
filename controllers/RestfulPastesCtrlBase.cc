/**
 *
 *  RestfulPastesCtrlBase.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#include "RestfulPastesCtrlBase.h"
#include <drogon/HttpResponse.h>
#include <drogon/HttpTypes.h>
#include <trantor/utils/Logger.h>

Task<HttpResponsePtr> RestfulPastesCtrlBase::getOne(HttpRequestPtr request,
                                                    const std::string &code) {

  auto dbClientPtr = getDbClient();

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "SELECT content FROM pastes WHERE code = $1", code);

    if (result.size()) {
      auto response = HttpResponse::newHttpResponse();
      response->setBody(result.front()["content"].as<std::string>());
      co_return response;
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k404NotFound);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

Task<HttpResponsePtr>
RestfulPastesCtrlBase::updateOne(HttpRequestPtr request,
                                 const std::string &token) {
  auto dbClientPtr = getDbClient();
  std::string content(request->getBody());

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "UPDATE pastes SET content=$1 WHERE token::text=$2", content, token);
    if (result.affectedRows()) {
      co_return HttpResponse::newHttpResponse();
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k401Unauthorized);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

Task<HttpResponsePtr>
RestfulPastesCtrlBase::deleteOne(HttpRequestPtr request,
                                 const std::string &token) {

  auto dbClientPtr = getDbClient();

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "DELETE FROM pastes WHERE token::text = $1", token);
    if (result.affectedRows()) {
      co_return HttpResponse::newHttpResponse();
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k401Unauthorized);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

Task<HttpResponsePtr> RestfulPastesCtrlBase::create(HttpRequestPtr request) {
  auto dbClientPtr = getDbClient();

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "INSERT INTO pastes(content) VALUES($1) RETURNING code, token",
        request->getBody());
    const auto &row = result.front();
    Json::Value response;
    response["code"] = row["code"].as<std::string>();
    response["token"] = row["token"].as<std::string>();
    co_return HttpResponse::newHttpJsonResponse(response);
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}
