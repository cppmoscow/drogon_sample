/**
 *
 *  RestfulPastesCtrlBase.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#include "RestfulPastesCtrlBase.h"
#include <drogon/HttpResponse.h>
#include <drogon/HttpTypes.h>
#include <drogon/utils/FunctionTraits.h>
#include <trantor/utils/Logger.h>

namespace {

const std::string kSelectPaste = "SELECT content FROM pastes WHERE code = $1";
const std::string kUpdatePaste =
    "UPDATE pastes SET content=$1 WHERE token::text=$2";
const std::string kDeletePaste = "DELETE FROM pastes WHERE token::text = $1";
const std::string kInsertPaste =
    "INSERT INTO pastes(content) VALUES($1) RETURNING code, token";

HttpResponsePtr databaseErrorResponse([]() {
  Json::Value result;
  result["error"] = "database error";
  auto response = HttpResponse::newHttpJsonResponse(result);
  response->setStatusCode(k500InternalServerError);
  return response;
}());

HttpResponsePtr notFoundErrorResponse([]() {
  auto response = HttpResponse::newHttpResponse();
  response->setStatusCode(drogon::k404NotFound);
  return response;
}());

HttpResponsePtr authErrorResponse([]() {
  auto response = HttpResponse::newHttpResponse();
  response->setStatusCode(drogon::k401Unauthorized);
  return response;
}());

} // namespace

Task<HttpResponsePtr> RestfulPastesCtrlBase::getOne(HttpRequestPtr request,
                                                    const std::string &code) {

  auto dbClientPtr = getDbClient();

  try {
    auto result = co_await dbClientPtr->execSqlCoro(kSelectPaste, code);

    if (result.size()) {
      auto response = HttpResponse::newHttpResponse();
      response->setBody(result.front()["content"].as<std::string>());
      co_return response;
    } else {
      co_return notFoundErrorResponse;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    co_return databaseErrorResponse;
  }
}

Task<HttpResponsePtr>
RestfulPastesCtrlBase::updateOne(HttpRequestPtr request,
                                 const std::string &token) {
  auto dbClientPtr = getDbClient();
  std::string content(request->getBody());

  try {
    auto result =
        co_await dbClientPtr->execSqlCoro(kUpdatePaste, content, token);
    if (result.affectedRows()) {
      co_return HttpResponse::newHttpResponse();
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k401Unauthorized);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    co_return databaseErrorResponse;
  }
}

Task<HttpResponsePtr>
RestfulPastesCtrlBase::deleteOne(HttpRequestPtr request,
                                 const std::string &token) {

  auto dbClientPtr = getDbClient();

  try {
    auto result = co_await dbClientPtr->execSqlCoro(kDeletePaste, token);
    if (result.affectedRows()) {
      co_return HttpResponse::newHttpResponse();
    } else {
      co_return authErrorResponse;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    co_return databaseErrorResponse;
  }
}

Task<HttpResponsePtr> RestfulPastesCtrlBase::create(HttpRequestPtr request) {
  auto dbClientPtr = getDbClient();

  try {
    auto result =
        co_await dbClientPtr->execSqlCoro(kInsertPaste, request->getBody());
    const auto &row = result.front();
    Json::Value response;
    response["code"] = row["code"].as<std::string>();
    response["token"] = row["token"].as<std::string>();
    co_return HttpResponse::newHttpJsonResponse(response);
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    co_return databaseErrorResponse;
  }
}
