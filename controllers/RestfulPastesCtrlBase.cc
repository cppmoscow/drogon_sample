/**
 *
 *  RestfulPastesCtrlBase.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#include "RestfulPastesCtrlBase.h"
#include <drogon/HttpResponse.h>
#include <drogon/HttpTypes.h>
#include <drogon/orm/Exception.h>
#include <exception>
#include <string>
#include <trantor/utils/Logger.h>

void RestfulPastesCtrlBase::getOne(
    const HttpRequestPtr &request,
    std::function<void(const HttpResponsePtr &)> &&callback,
    const std::string &code) {

  auto dbClientPtr = drogon::app().getDbClient("pastes-database");
  auto callbackPtr =
      std::make_shared<std::function<void(const HttpResponsePtr &)>>(
          std::move(callback));

  dbClientPtr->execSqlAsync(
      "SELECT content FROM pastes WHERE code = $1",
      [request, callbackPtr](const drogon::orm::Result &result) {
        if (result.size()) {
          auto response = HttpResponse::newHttpResponse();
          response->setBody(result.front()["content"].as<std::string>());
          (*callbackPtr)(response);
        } else {
          auto response = HttpResponse::newHttpResponse();
          response->setStatusCode(drogon::k404NotFound);
          (*callbackPtr)(response);
        }
      },
      [callbackPtr](const DrogonDbException &e) {
        LOG_ERROR << e.base().what();
        Json::Value ret;
        ret["error"] = "database error";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k500InternalServerError);
        (*callbackPtr)(resp);
      },
      code);
}

void RestfulPastesCtrlBase::updateOne(
    const HttpRequestPtr &request,
    std::function<void(const HttpResponsePtr &)> &&callback,
    const std::string &token) {
  std::string content(request->getBody());

  auto dbClientPtr = drogon::app().getDbClient("pastes-database");
  auto callbackPtr =
      std::make_shared<std::function<void(const HttpResponsePtr &)>>(
          std::move(callback));

  dbClientPtr->execSqlAsync(
      "UPDATE pastes SET content=$1 WHERE token::text=$2",
      [request, callbackPtr](const drogon::orm::Result &result) {
        if (result.affectedRows()) {
          (*callbackPtr)(HttpResponse::newHttpResponse());
        } else {
          auto response = HttpResponse::newHttpResponse();
          response->setStatusCode(drogon::k401Unauthorized);
          (*callbackPtr)(response);
        }
      },
      [callbackPtr](const DrogonDbException &e) {
        LOG_ERROR << e.base().what();
        Json::Value ret;
        ret["error"] = "database error";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k500InternalServerError);
        (*callbackPtr)(resp);
      },
      content, token);
}

void RestfulPastesCtrlBase::deleteOne(
    const HttpRequestPtr &request,
    std::function<void(const HttpResponsePtr &)> &&callback,
    const std::string &token) {

  auto dbClientPtr = drogon::app().getDbClient("pastes-database");
  auto callbackPtr =
      std::make_shared<std::function<void(const HttpResponsePtr &)>>(
          std::move(callback));

  dbClientPtr->execSqlAsync(
      "DELETE FROM pastes WHERE token::text = $1",
      [request, callbackPtr](const drogon::orm::Result &result) {
        if (result.affectedRows()) {
          (*callbackPtr)(HttpResponse::newHttpResponse());
        } else {
          auto response = HttpResponse::newHttpResponse();
          response->setStatusCode(drogon::k401Unauthorized);
          (*callbackPtr)(response);
        }
      },
      [callbackPtr](const DrogonDbException &e) {
        LOG_ERROR << e.base().what();
        Json::Value ret;
        ret["error"] = "database error";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k500InternalServerError);
        (*callbackPtr)(resp);
      },
      token);
}

void RestfulPastesCtrlBase::create(
    const HttpRequestPtr &request,
    std::function<void(const HttpResponsePtr &)> &&callback) {
  auto dbClientPtr = drogon::app().getDbClient("pastes-database");
  auto callbackPtr =
      std::make_shared<std::function<void(const HttpResponsePtr &)>>(
          std::move(callback));
  bool needInsertion = true;
  std::string content(request->getBody());
  dbClientPtr->execSqlAsync(
      "INSERT INTO pastes(content) VALUES($1) RETURNING code, token",
      [request, callbackPtr](const drogon::orm::Result &result) {
        const auto &row = result.front();
        Json::Value ret;
        ret["code"] = row["code"].as<std::string>();
        ret["token"] = row["token"].as<std::string>();
        (*callbackPtr)(HttpResponse::newHttpJsonResponse(ret));
      },
      [callbackPtr](const DrogonDbException &e) {
        LOG_ERROR << e.base().what();
        Json::Value ret;
        ret["error"] = "database error";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k500InternalServerError);
        (*callbackPtr)(resp);
      },
      content);
}

RestfulPastesCtrlBase::RestfulPastesCtrlBase()
    : RestfulController({"id", "code", "content", "token"}) {
  /**
   * The items in the vector are aliases of column names in the table.
   * if one item is set to an empty string, the related column is not sent
   * to clients.
   */
  enableMasquerading({
      "id",      // the alias for the id column.
      "code",    // the alias for the code column.
      "content", // the alias for the content column.
      "token"    // the alias for the token column.
  });
}
