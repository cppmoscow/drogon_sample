/**
 *
 *  RestfulPastesCtrlBase.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#include "RestfulPastesCtrlBase.h"
#include <drogon/HttpResponse.h>
#include <drogon/HttpTypes.h>
#include <drogon/orm/Exception.h>
#include <drogon/utils/FunctionTraits.h>
#include <exception>
#include <string>
#include <trantor/utils/Logger.h>

Task<HttpResponsePtr> RestfulPastesCtrlBase::getOne(HttpRequestPtr request,
                                                    const std::string &code) {

  auto dbClientPtr = drogon::app().getDbClient("pastes-database");

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "SELECT content FROM pastes WHERE code = $1", code);

    if (result.size()) {
      auto response = HttpResponse::newHttpResponse();
      response->setBody(result.front()["content"].as<std::string>());
      co_return response;
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k404NotFound);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

Task<HttpResponsePtr>
RestfulPastesCtrlBase::updateOne(HttpRequestPtr request,
                                 const std::string &token) {
  auto dbClientPtr = drogon::app().getDbClient("pastes-database");
  std::string content(request->getBody());

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "UPDATE pastes SET content=$1 WHERE token::text=$2", content, token);
    if (result.affectedRows()) {
      co_return HttpResponse::newHttpResponse();
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k401Unauthorized);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

Task<HttpResponsePtr>
RestfulPastesCtrlBase::deleteOne(HttpRequestPtr request,
                                 const std::string &token) {

  auto dbClientPtr = drogon::app().getDbClient("pastes-database");

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "DELETE FROM pastes WHERE token::text = $1", token);
    if (result.affectedRows()) {
      co_return HttpResponse::newHttpResponse();
    } else {
      auto response = HttpResponse::newHttpResponse();
      response->setStatusCode(drogon::k401Unauthorized);
      co_return response;
    }
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

Task<HttpResponsePtr> RestfulPastesCtrlBase::create(HttpRequestPtr request) {
  auto dbClientPtr = drogon::app().getDbClient("pastes-database");

  try {
    auto result = co_await dbClientPtr->execSqlCoro(
        "INSERT INTO pastes(content) VALUES($1) RETURNING code, token",
        request->getBody());
    const auto &row = result.front();
    Json::Value response;
    response["code"] = row["code"].as<std::string>();
    response["token"] = row["token"].as<std::string>();
    co_return HttpResponse::newHttpJsonResponse(response);
  } catch (const DrogonDbException &err) {
    LOG_ERROR << err.base().what();
    Json::Value result;
    result["error"] = "database error";
    auto response = HttpResponse::newHttpJsonResponse(result);
    response->setStatusCode(k500InternalServerError);
    co_return response;
  }
}

RestfulPastesCtrlBase::RestfulPastesCtrlBase()
    : RestfulController({"id", "code", "content", "token"}) {
  /**
   * The items in the vector are aliases of column names in the table.
   * if one item is set to an empty string, the related column is not sent
   * to clients.
   */
  enableMasquerading({
      "id",      // the alias for the id column.
      "code",    // the alias for the code column.
      "content", // the alias for the content column.
      "token"    // the alias for the token column.
  });
}
